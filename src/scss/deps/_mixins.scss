// Order of the includes matters, and it is: normal, bold, italic, bold+italic.
@mixin font-face($font-family, $file-path, $weight: normal, $style: normal, $asset-pipeline: false) {
  @font-face {
    font-family: quote($font-family);

    @if $asset-pipeline==true {
      src: font-url('#{$file-path}.eot');
      src: font-url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
      font-url('#{$file-path}.woff') format('woff'),
      font-url('#{$file-path}.ttf') format('truetype'),
      font-url('#{$file-path}.svg##{$font-family}') format('svg');
    }

    @else {
      src: url('#{$file-path}.eot');
      src: url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
      url('#{$file-path}.woff') format('woff'),
      url('#{$file-path}.ttf') format('truetype'),
      url('#{$file-path}.svg##{$font-family}') format('svg');
    }

    font-weight: $weight;
    font-style: $style;
  }
}

// Input placeholder
@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder {
    @content;
  }

  &::-moz-placeholder {
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

// line-height - divide desired line-height by font-size
@mixin line-height($line-height: $base-line-height, $font-size: $base-font-size) {
  line-height: $line-height / $font-size;
}

@mixin margin-bottom($line-height: $base-line-height, $font-size: $base-font-size) {
  margin-bottom: $line-height / $font-size + em;
}

// Vertical rhythm - combines font-size, line-height, and margin-bottom
@mixin vertical-rhythm($line-height: $base-line-height, $font-size: $base-font-size, $margin-divide: 2) {
  font-size: #{$font-size}px;
  font-size: #{$font-size / 10}rem;
  line-height: $line-height / $font-size;
  margin-bottom: ($line-height / $font-size) / $margin-divide + em;
}

// Helpers
// ----------------------------------------------

// Image replacement
@mixin ir {
  overflow: hidden;
  border: 0;
  background-color: transparent;
  *text-indent: -9999px;

  &:before {
    display: block;
    width: 0;
    height: 150%;
    content: "";
  }
}

// Center align block element
@mixin center {
  display: block;
  margin-right: auto;
  margin-left: auto;
}

@mixin text-overflow {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

@mixin circle {
  display: inline-block;
  overflow: hidden;
  border-radius: 50%;
}

@mixin vertical-align {
  position: relative;
  top: 50%;
  transform: translateY(-50%);
}

// a map-set function (not included with Sass)
@function map-set($map, $key, $value) {
  $new: ($key: $value);
  @return map-merge($map, $new);
}


// You can assign the parent/block selector to a variable --> $b: #{&};
// .top { $b: #{&}; }
// Then no matter how many times you nest selectors you can still get the output of .parent__selector:
// .......... @include __(layer3, #{$b}) { ... Outputs .top__layer3 }
@mixin __($selector, $root) {
  @at-root #{$root+$elementSeparator+$selector} {
    @content;
  }
}


@mixin dynamic($map, $properties...) {
  // Get the number of provided breakpoints
  $length: length(map-keys($map));

  @each $property in $properties {

  // Error if the number of breakpoints is < 2
  @if $length < 2 {
    @error 'poly-property() $map requires at least values';
  }

  // Sort the map by viewport width (key)
  $map: map-sort($map);
  $keys: map-keys($map);

  // Minimum size
  #{$property}: map-get($map, nth($keys, 1));

  @for $i from 1 through $length - 1 {
    @media (min-width: nth($keys, $i)) {
      $value: map-get($map, nth($keys, $i));
      #{$property}: $value;
    }
  }

  // Maxmimum size
  @media (min-width: nth($keys, $length)) {
    #{$property}: map-get($map, nth($keys, $length));
  }
}
}


/// dynamicCalc
/// Generate linear interpolated size values through multiple break points
/// @param $property - A string CSS property name
/// @param $map - A Sass map of viewport unit and size value pairs
/// @example
///   @include dynamicCalc((576px: 22px, 768px: 24px, 992px: 34px), 'font-size, line-height');
///   You can use any unit type, but you can't mix them (576px: 3rem)

@mixin dynamicCalc($map, $properties...) {
  // Get the number of provided breakpoints
  $length: length(map-keys($map));

  @each $property in $properties {

  // Error if the number of breakpoints is < 2
  @if $length < 2 {
    @error 'dynamicCalc() $map requires at least values';
  }

  // Sort the map by viewport width (key)
  $map: map-sort($map);
  $keys: map-keys($map);

  // Minimum size
  #{$property}: map-get($map, nth($keys, 1));

  // Interpolated size through breakpoints
  @for $i from 1 through $length - 1 {
    @media (min-width: nth($keys, $i)) {
      $value1: map-get($map, nth($keys, $i));
      $value2: map-get($map, nth($keys, $i + 1));

      // If values are not equal, perform linear interpolation
      @if $value1 != $value2 {
        #{$property}: linear-interpolation((nth($keys, $i): $value1, nth($keys, $i + 1): $value2));
      }

      @else {
        #{$property}: $value1;
      }
    }
  }

  // Maxmimum size
  @media (min-width: nth($keys, $length)) {
    #{$property}: map-get($map, nth($keys, $length));
  }
  }
}



/// Prefixes selector $class with breakpoint keywords, allowing you to create a batch of breakpoint classes with one chunk of code. If you want to skip a breakpoint (like small, because mobile first and all that), add values to the $omit parameter.
///
/// @param {string} $class - Class to prefix with the breakpoint name and a hyphen.
/// @param {list} $omit - Named breakpoints to skip. No class will be added with breakpoints in this list.
@mixin each-breakpoint($class, $omit: ()) {
  // Iterate through breakpoint classes
  @each $size in $breakpoint-classes {
    // Only do something if the breakpoint is not in $omit
    @if index($omit, $size) == null {
      $val: map-get($breakpoints, $size);
      // Prefix $class with $size and a hyphen
      .#{$size + '-' + $class} {
        @include breakpoint($size) {
          @content;
        }
      }
    }
  }
}

@mixin shadowBasic ($level) {
	@if $level == 1 {
		box-shadow: 0 0.125em 0.313em rgba(50,50,93,.09), 0 0.063em 0.125em rgba(0,0,0,.07);
	} @else if $level == 2 {
    box-shadow: 0 0.250em 0.375em rgba(50,50,93,.09), 0 0.063em 0.188em rgba(0,0,0,.08);
	} @else if $level == 3 {
    box-shadow: 0 0.063em 0.313em 0 rgba(0,0,0,.07), 0 0.438em 1.063em 0 rgba(0,0,0,.1);
	} @else if $level == 4 {
    box-shadow: 0 0.938em 2.188em rgba(50,50,93,.1), 0 0.313em 0.938em rgba(0,0,0,.07);
	} @else if $level == 5 {
    box-shadow: 0 0.938em 2.188em rgba(50,50,93,.15), 0 0.313em 0.938em rgba(0,0,0,.1);
	}
}

// You can specify multiple specific properties using $properties: 'prop1, prop2, prop3'
// Quotes are needed to pass multiple values for one parameter
@mixin shadow(
  $move:              true,
  $hoverOnly:         false,
  $borderRadius:      0,
  $x:                 0,
  $y:                 rem-calc(6),
  $blur:              rem-calc(12),
  $color:           rgba(0, 0, 0, .2),
  $properties:        all,
  $time:              .2s,
  $timeFunction:      ease,
  $distance:          rem-calc(4),
  $newX:              0,
  $newY:              rem-calc(7),
  $newBlur:           rem-calc(15),
  $newColor:        rgba(0, 0, 0, .3)) {

  position: relative;
  border-radius: $borderRadius;
  @if $move == true { bottom: 0; }
  @if $hoverOnly == false { box-shadow: $x $y $blur $color; }

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0;
    box-shadow: $newX $newY $newBlur $newColor;
    transition: opacity $time #{$timeFunction};
    border-radius: $borderRadius;
  }

  &:hover, &:focus {
    // This is to allow you to have properties with different
    // timings or functions than the shadow opacity
    // Interpolation removes any quotes that were passed with the parameter
    transition-property: #{$properties};
    transition-duration: $time;
    transition-timing-function: #{$timeFunction};
    @if $move == true { bottom: $distance; }

    &::after { opacity: 1; }
  }
}
