// Order of the includes matters, and it is: normal, bold, italic, bold+italic.
@mixin font-face($font-family, $file-path, $weight: normal, $style: normal, $asset-pipeline: false) {
  @font-face {
    font-family: quote($font-family);

    @if $asset-pipeline==true {
      src: font-url('#{$file-path}.eot');
      src: font-url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
      font-url('#{$file-path}.woff') format('woff'),
      font-url('#{$file-path}.ttf') format('truetype'),
      font-url('#{$file-path}.svg##{$font-family}') format('svg');
    }

    @else {
      src: url('#{$file-path}.eot');
      src: url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
      url('#{$file-path}.woff') format('woff'),
      url('#{$file-path}.ttf') format('truetype'),
      url('#{$file-path}.svg##{$font-family}') format('svg');
    }

    font-weight: $weight;
    font-style: $style;
  }
}

// Input placeholder
@mixin placeholder {
  &::-webkit-input-placeholder {
    @content;
  }

  &:-moz-placeholder {
    @content;
  }

  &::-moz-placeholder {
    @content;
  }

  &:-ms-input-placeholder {
    @content;
  }
}

// line-height - divide desired line-height by font-size
@mixin line-height($line-height: $base-line-height, $font-size: $base-font-size) {
  line-height: $line-height / $font-size;
}

@mixin margin-bottom($line-height: $base-line-height, $font-size: $base-font-size) {
  margin-bottom: $line-height / $font-size + em;
}

// Vertical rhythm - combines font-size, line-height, and margin-bottom
@mixin vertical-rhythm($line-height: $base-line-height, $font-size: $base-font-size, $margin-divide: 2) {
  font-size: #{$font-size}px;
  font-size: #{$font-size / 10}rem;
  line-height: $line-height / $font-size;
  margin-bottom: ($line-height / $font-size) / $margin-divide + em;
}

// Helpers
// ----------------------------------------------

// Image replacement
@mixin ir {
  overflow: hidden;
  border: 0;
  background-color: transparent;
  *text-indent: -9999px;

  &:before {
    display: block;
    width: 0;
    height: 150%;
    content: "";
  }
}

// Center align block element
@mixin center {
  display: block;
  margin-right: auto;
  margin-left: auto;
}

@mixin text-overflow {
  display: block;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

@mixin circle {
  display: inline-block;
  overflow: hidden;
  border-radius: 50%;
}

@mixin vertical-align {
  position: relative;
  top: 50%;
}



@mixin shadow($move: true, $hoverOnly: false, $borderRadius: 0, $x: 0, $y: rem-calc(3), $blur: rem-calc(10), $color: rgba(0, 0, 0, .3), $properties: all, $time: .2s, $timeFunction: ease, $distance: rem-calc(4), $newX: 0, $newY: rem-calc(7), $newBlur: rem-calc(15), $newColor: rgba(0, 0, 0, .3)) {
  // If using the variable:value pair syntax, you can pass them in any order
  // You can pass as many as you want, anything you don't include will use the default value


  // You can specify multiple specific properties using $properties: 'prop1, prop2, prop3', which is useful for transition properties
  // Quotes are needed to pass multiple values for one parameter

  // Uses transition on psuedo-element opacity for better performance,
  // since opacity transitions don't trigger paint redraws,
  // while box-shadow transitions constantly trigger paint redraws

  position: relative;
  @if $move == true {
    bottom: 0;
  }

  @if $hoverOnly == false {
    box-shadow: $x $y $blur $color;
  }

  &:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    width: 100%;
    height: 100%;
    opacity: 0;
    box-shadow: $newX $newY $newBlur $newColor;
    transition: opacity $time #{$timeFunction};
    border-radius: $borderRadius;
  }

  &:hover, &:focus {
    transition-property: #{$properties}; // Interpolation removes any quotes that were passed with the parameter
    transition-duration: $time;
    transition-timing-function: #{$timeFunction};

    @if $move == true {
      bottom: $distance;
      z-index: 1;
    }

    &::after {
      opacity: 1;
    }
  }
}


// You can assign the parent/block selector to a variable --> $b: #{&};
// .top { $b: #{&}; }
// Then no matter how many times you nest selectors you can still get the output of .parent__selector:
// .......... @include root(layer3, #{$b}) { ... Outputs .top__layer3 }
@mixin root($selector, $root) {
  @at-root #{$root+$elementSeparator+$selector} {
    @content;
  }
}

@function list-remove($list, $index) {
  $newList: ();

  @for $i from 1 through length($list) {
    @if $i != $index {
      $newList: append($newList, nth($list, $i), 'space');
    }
  }

  @return $newList;
}

@function list-sort($list) {
  $sortedlist: ();

  @while length($list) > 0 {
    $value: nth($list, 1);

    @each $item in $list {
      @if $item < $value {
        $value: $item;
      }
    }

    $sortedlist: append($sortedlist, $value, 'space');

    $list: list-remove($list, index($list, $value));
  }

  @return $sortedlist;
}

@function map-sort($map) {
  $keys: list-sort(map-keys($map));
  $sortedMap: ();

  @each $key in $keys {
    $sortedMap: map-merge($sortedMap, ($key: map-get($map, $key)));
  }

  @return $sortedMap;
}

@function linear-interpolation($map) {
  $keys: map-keys($map);

  @if length($keys) != 2 {
    @error 'linear-interpolation() $map must be exactly 2 values';
  }

  // The slope
  $m: (map-get($map, nth($keys, 2)) - map-get($map, nth($keys, 1))) / (nth($keys, 2) - nth($keys, 1));

  // The y-intercept
  $b: map-get($map, nth($keys, 1)) - $m * nth($keys, 1);

  // Determine if the sign should be positive or negative
  $sign: '+';

  @if $b < 0 {
    $sign: '-';
    $b: abs($b);
  }

  @return calc(#{$m * 100}vw #{$sign} #{$b});
}

/// poly-fluid-sizing
/// Generate linear interpolated size values through multiple break points
/// @param $property - A string CSS property name
/// @param $map - A Sass map of viewport unit and size value pairs
/// @example
///   @include poly-fluid-sizing('font-size', (576px: 22px, 768px: 24px, 992px: 34px));
///   You can use any unit type, but you can't mix them (576px: 3rem)

@mixin poly-fluid-sizing($property, $map) {
  // Get the number of provided breakpoints
  $length: length(map-keys($map));

  // Error if the number of breakpoints is < 2
  @if $length < 2 {
    @error 'poly-fluid-sizing() $map requires at least values';
  }

  // Sort the map by viewport width (key)
  $map: map-sort($map);
  $keys: map-keys($map);

  // Minimum size
  #{$property}: map-get($map, nth($keys, 1));

  // Interpolated size through breakpoints
  @for $i from 1 through $length - 1 {
    @media (min-width: nth($keys, $i)) {
      $value1: map-get($map, nth($keys, $i));
      $value2: map-get($map, nth($keys, $i + 1));

      // If values are not equal, perform linear interpolation
      @if $value1 != $value2 {
        #{$property}: linear-interpolation((nth($keys, $i): $value1, nth($keys, $i + 1): $value2));
      }

      @else {
        #{$property}: $value1;
      }
    }
  }

  // Maxmimum size
  @media (min-width: nth($keys, $length)) {
    #{$property}: map-get($map, nth($keys, $length));
  }
}
